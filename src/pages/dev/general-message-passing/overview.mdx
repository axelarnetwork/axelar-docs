# General Message Passing

Axelar's General Message Passing (GMP) enables a developer building on one chain to call any function on any other connected chain. (We use the word "function" to encompass both smart contracts at the application layer and functions built at the protocol layer, as in Cosmos, for example.) That means complete composability across Web3.

With GMP, you can:

- Call a contract on chain B from chain A.
- Call a contract on chain B from chain A and attach some tokens.

### Prerequisites
- For GMP to work, chains A and B must be EVM or Cosmos with a deployed Axelar Gateway contract. We're adding new chains and chain technology stacks all of the time. This document primarily focuses on EVM chains and Solidity code, but you can [learn about interacting with Cosmos GMP](./cosmos-gmp).
- The application's executable contract must be deployed on the destination contract.
- The application must be on one of Axelar's supported EVM chains. See [chain names](../reference/mainnet-chain-names) for a list of EVM chains that have an Axelar Gateway deployed. The list is updated as new chains are added.

### Flow architecture (in steps)

![simple-gmp-diagram.png](/images/simple-gmp-diagram.png)

### Steps

#### At the source chain

1. User (dApp) calls a `callContract` (or `callContractWithToken`) function on the Axelar Gateway contract to initiate a call. Once the call is initiated, the user can see its status at https://axelarscan.io/gmp/[txHash] or programmatically track it via the [AxelarJS SDK](/dev/axelarjs-sdk/tx-status-query-recovery#query-transaction-status-by-txhash).
2. The user prepays the relayer gas fee on the source chain to Axelar's Gas Services contract.
3. The call enters the Axelar Gateway from the source chain.

#### At the Axelar network
4. The Axelar network confirms the call and converts the paid gas from the source chain's native token into the destination chain's native token.  

#### At the destination chain
5. The call is approved and emerges from the Axelar Gateway on the destination chain.
6. The executor service relays and executes the approved call to the application's Axelar Executable interface.

Suppose the paid gas (step 2) is insufficient to relay the transfer to the application interface (step 6). We have [monitoring and recovery](/dev/general-message-passing/monitoring) steps to help deal with such scenarios.


### Real-World Breakdown of Cross-Chain [Contract Calls](https://axelarscan.io/gmp/0x93cb0b614b07d6050b164cc3e35da617a2fbefc13069a35369894cac74b861a2:54) 

![gmp-diagram.png](/images/gmp-diagram.png)

#### Setup

a. The destination application contract implements the `IAxelarExecutable.sol` interface to receive the cross-chain message.

b. The destination application contract stores the address of the destination chain's Axelar gateway contract.

#### On Source Chain
1. A smart contract on the source chain [calls](https://moonscan.io/tx/0x93cb0b614b07d6050b164cc3e35da617a2fbefc13069a35369894cac74b861a2) `AxelarGateway.callContract()` with the destination chain/address and `payload`, which emits the `ContractCall` event.

2. The smart contract can optionally deposit tokens to the [`AxelarGasService`](https://github.com/axelarnetwork/axelar-cgp-solidity/blob/main/contracts/gas-service/AxelarGasService.sol#L122) contract in the same transaction to pay the Axelar relayers for submitting the intermediate transactions required for cross-chain execution.

#### On Axelar Network

3. A relayer monitors the `ContractCall` event and submits a transaction to the Axelar network to request validation. The relayer also stores the `payload` in a database, keyed by `hash(payload)` for later retrieval.

4. Axelar validators then [vote](https://axelarscan.io/evm-poll/434420) on-chain to validate the `ContractCall` event content.

5. A relayer requests the Axelar network to prepare a command batch, including the pending payload approval (potentially batched with other messages), and requests validator signatures.

6. A signed [batch](https://axelarscan.io/evm-batches?commandId=0x47d0de91330856d70caecf442341be3faf6e644b83892b214c5a2bcc673ba8ca) of approved payloads is prepared on Axelar that anyone can view.

#### On Destination Chain

7. A relayer [submits](https://bscscan.com/tx/0x72e6c040bfbf26073cdcf55cc4db571badcadd3b9316cf0f53b72f980d3e5100) the signed batch to the destination gateway contract, which records the [approval](https://github.com/axelarnetwork/cgp-spec/blob/main/solidity/contracts/AxelarGateway.sol#L109) of the payload hash and emits a `ContractCallApproved` [event](https://github.com/axelarnetwork/cgp-spec/blob/main/solidity/contracts/AxelarGateway.sol#L144).

8. A relayer service(can be anyone) listens for this event and [calls](https://bscscan.com/tx/0x24886831c6348f036be26193d3fd74f2a08b9b9c10cae4e4bb99677687d8b71f) `IAxelarExecutable.execute()` on the destination contract with the `payload` and other data as params.

9. The `execute` method on the destination [contract](https://github.com/axelarnetwork/cgp-spec/blob/main/solidity/contracts/executable/AxelarExecutable.sol#L18) verifies the call was indeed approved by Axelar validators by calling `validateContractCall()` on its Axelar gateway contract.

10. The gateway [records](https://github.com/axelarnetwork/cgp-spec/blob/main/solidity/contracts/AxelarGateway.sol#L60) that the destination application contract validated the approval and did not allow `validateContractCall` to be called again (to prevent replay of `execute`).

11. The destination application contract uses the `payload` to [execute](https://github.com/axelarnetwork/cgp-spec/blob/main/solidity/contracts/executable/AxelarExecutable.sol#L23) it's logic.