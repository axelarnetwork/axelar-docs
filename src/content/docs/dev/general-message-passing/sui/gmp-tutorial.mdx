import { Callout } from "../../../../../components/callout";

# General Message Passing (GMP) Sui Example

The following is an end-to-end example of how to use the General Message Passing (GMP) feature in Sui. This example demonstrates how to create a simple cross-chain application that allows users to send messages between Sui and an [EVM](https://ethereum.org/en/developers/docs/evm/) chain. 

## Prerequisites
Before you begin, make sure you have the following prerequisites installed:
- [Rust](https://www.rust-lang.org/tools/install)
- [Sui CLI](https://docs.sui.io/build/install)
- [Sui Move](https://docs.sui.io/build/move)
- [Sui JS](https://www.npmjs.com/package/@mysten/sui)

## Setup 

This demo will use Sui's Typescript SDK to build and deploy the `move` based on contract. It will use `npm` to install the required dependencies. To begin you can run the following command to spin-up your Sui repository.

```bash
sui move new sui-gmp
```

This will create a new directory called `sui-gmp` with the following structure:

1. `Move.toml`    
1. `sources`      
1. `tests`

You can the run `npm init -y` to add a `package.json` file to the project.

### Move Config

The main configuration for a Sui project is in the `move.toml` file. This file contains the following sections:
- `[package]`: This section contains the package name, version, and authors.
- `[dependencies]`: This section contains the dependencies for the package.
- `[addresses]`: The live addresses of the dependencies for your project.
- `[dev-dependencies]`: The dev-dependencies section allows overriding dependencies for `--test`.
- `[dev-addresses]`: The dev-addresses section allows overwriting named addresses for the `--test`.

For now you can clear the boiler plate config and simply add the following:

```toml
[package]
name = "gmp_example"
version = "0.1.0"
edition = "2024"
```

## GMP Package

The GMP Package (akin to a smart contract in the EVM ecosystem) will hold the core logic for the cross-chain application. It will be built using the `move` programming language. You can start it off by creating a new `gmp_example.move` file in the `sources` folder adding the name for the module in the code.

```move
module gmp_example::gmp;
```

Note: The name `gmp_example` must match the name provided in the `move.toml` file that holds the 

### Dependencies 

TODO

### Imports

TODO`

### `Singleton`

The singleton is a resource type that lives in its own on-chain [object](https://docs.sui.io/concepts/object-model). In the case of this package this object owns the package's [channel](src/content/docs/dev/general-message-passing/sui/gmp-contracts#channel). The `id` of the singleton gives it a unique on-chain object identity.

You can create your package's singleton as follows: 

```rust
public struct Singleton has key {
    id: object::UID,
    channel: Channel,
}
```

Where the `id` is the unique identifier for the on-chain object and the `channel` is imported from the [Gateway dependency](https://github.com/axelarnetwork/axelar-cgp-sui/tree/main/move/axelar_gateway).

### `Init`

With your singleton now setup, you can create your `initialize` function that will be used to [initialize](https://move-book.com/programmability/module-initializer.html) the GMP package. This function will take a single parameter:

1. `ctx: &mut TxContext`: A mutable reference to [TxContext](https://docs.sui.io/references/framework/sui/tx_context#sui_tx_context_TxContext)

In the `init` function you can then setup a new `object` id, create your unique `channel` and associate the two together via the [transfer::share_object](https://docs.sui.io/references/framework/sui/transfer#sui_transfer_share_object) function to publish a `singleton` resource. 

```rust
fun init(ctx: &mut TxContext) {
    // Create a new object id for the singleton
    let singletonId = object::new(ctx);
    // Create a new channel
    let channel = channel::new(ctx);
    // Publish the singleton
    transfer::share_object(Singleton {
        id: singletonId,
        channel,
    });
}
```

### `Send_Message`

With your `channel` now setup for your package you can begin to write the functionality to actually send the cross-chain message. The `send_message()` function will take the following parameters:

1. `singleton: &Singleton`: A reference to the `singleton` resource to identify the `channel`
1. `gateway: &Gateway`: A reference to the [gateway's](/dev/general-message-passing/sui/gmp-example/#sui-gateway) published object id that contains key Axelar functionality
1. `gas_service: &mut GasService`: A mutable reference to the [gas service's](/dev/general-message-passing/sui/gmp-example/#sui-gas-service) object id 
1. `destination_chain: String`: The name of the destination chain to send the message to
1. `destination_address: String`: The recipient address on the destination chain
1. `payload: vector<u8>`: The payload to send to the destination chain
1. `refund_address: address`: The address to send any surplus gas payment back to
1. `coin: Coin<SUI>`: The gas coin to be spent on message delivery
1. `params: vector<u8>`: For future use, this parameter is currently unused

The function signature can be written out as follows: 

```rust
public fun send_message(
    singleton: &Singleton,
    gateway: &Gateway,
    gas_service: &mut GasService,
    destination_chain: String,
    destination_address: String,
    payload: vector<u8>,
    refund_address: address,
    coin: Coin<SUI>,
    params: vector<u8>,
) {}
```

Note: the `gas_service` param is of specified as mutable because you will eventually update the `GasService` resource’s internal state (by consuming the provided coin).

You can now begin to implement the functionality for `send_message()`.

First you can create a new [Message Ticket](/dev/general-message-passing/sui/gmp-example/#message-ticket). This can be interacting with the `Gateway's` `prepare_message()` function. 
 
```rust
let message_ticket = gateway::prepare_message(
    &singleton.channel,
    destination_chain,
    destination_address,
    payload,
);
```

The ticket will contain all the relevant parameters needed when triggering a cross-chain message.

Next, you can interact with the `GasService` to pay for the entirety of the cross chain call from the source chain. This can be done by triggering the `pay_gas()` function. The gas payment will be picked up by an Axelar relayer and eventually used to pay for the [execution fee](/dev/gas-service/pay-gas/#execution-fee) on the destination chain. 

```rust
gas_service.pay_gas(
    &message_ticket,
    coin,
    refund_address,
    params,
);
```

Lastly, you can trigger the Gateway's `send_message()` function to trigger the cross-chain message by passing in the `message_ticket` you created earlier. 


```rust
gateway.send_message(message_ticket);
```

The complete `send_message()` function should look like this:

```rust
public fun send_message(
    singleton: &Singleton,
    gateway: &Gateway,
    gas_service: &mut GasService,
    destination_chain: String,
    destination_address: String,
    payload: vector<u8>,
    refund_address: address,
    coin: Coin<SUI>,
    params: vector<u8>,
) {
    // Create a new message ticket
    let message_ticket = gateway::prepare_message(
        &singleton.channel,
        destination_chain,
        destination_address,
        payload,
    );

    // Pay for the gas
    gas_service.pay_gas(
        &message_ticket,
        coin,
        refund_address,
        params,
    );

    // Dispatch the cross-chain message
    gateway.send_message(message_ticket);
}
```

### Receive Message

With the package now able to send cross-chain messages, it would be great to also receive messages from other blockchains. This can be done by creating an `execute()` function that will be triggered by our Axelar's relaying infrastructure for any incoming message. The full function signature for the `execute()` function will require two parameters:

1. `call: ApprovedMessage`: The [approved message](/dev/general-message-passing/sui/gmp-contracts/#approvedmessage) that was sent from the source chain
1. `singleton: &mut Singleton`: A mutable reference to the `singleton` resource so the package can consume messages from its `channel` 

```rust
public fun execute(
    call: ApprovedMessage, 
    singleton: &mut Singleton
) {}
```

Within the `execute()` function you can then consume the message by triggering the [consume_approved_message()](/dev/general-message-passing/sui/gmp-contracts/#consume-approved-message) function that is [defined](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/axelar_gateway/sources/channel.move#L85) in the `Channel` module. Once the message is approved you can `emit` a custom event indicating that the execution has gone through successfully. 

Your complete `execute()` function should look like this:

```rust
public fun execute(
    call: ApprovedMessage, 
    singleton: &mut Singleton
) {
    // Consume the message
    let (_, _, _, payload) = singleton.channel.consume_approved_message(call);

    // Emit Executed event
    event::emit(Executed { data: payload });
}
```

This will lead to an error however as you have not yet defined your event, you can do so up top as follows. Note unlike the `Singleton` struct that had a `key` allowing it to be its own on-chain object, the `Executed` struct has a `copy` + `drop` [abilities](https://docs.sui.io/references/sui-api/sui-graphql/reference/types/enums/move-ability) so the event data can be duplicated into the transaction’s event log and then discarded by off-chain indexers. The event itself simply takes a raw payload of bytes that it will be receiving in the cross-chain call.

```rust
public struct Executed has copy, drop {
    data: vector<u8>,
}
```

With the event now defined up top you should be able to compile the package successfully.

### Register Transaction

Unlike in EVM chains, Sui cross-chain transactions involve an additional step to be able to receive cross-chain messages, beyond just defining the `execute()` function. Packages must be [registered](/dev/general-message-passing/sui/gmp-contracts/#relayer-discovery) with the [Relayer Discovery](https://github.com/axelarnetwork/axelar-cgp-sui/tree/main/move/relayer_discovery). 

You can define a specific function your contract to do just that. The `register_transaction()` function will take the following parameters:

1. `discovery: &mut RelayerDiscovery`: A mutable reference to the `Relayer Discovery` object id. Mutable as the state of the Relayer Discovery will be updated to set the new transaction.
1. `singleton: &Singleton`: A mutable reference to the `singleton` resource.

```rust
public fun register_transaction(
    discovery: &mut RelayerDiscovery, 
    singleton: &Singleton) {
}
```

The first thing you will need to do is create a nested vector for the arguments that will be used by the relayer when calling the `execute()` function.

```rust
let arguments = vector[
    //arg `2` corresponding to ApprovedMessage
    vector[2u8],
    //arg `0` corresponding to an object, which in this case is the singleton 
    concat(vector[0u8], object::id_address(singleton).to_bytes()),
];
```

The `vector[2u8]` corresponds to the `ApprovedMessage` argument that the relayer will need to pass in to the `execute()` function. It is one of [five argument types](/dev/general-message-passing/sui/gmp-contracts/relayer-discover/#argument-types) that the relayer will know how to handle. 

Now that the relayer knows to submit the `ApprovedMessage` to the `execute()` function you can also pass the id of the singleton that will consume the message. To pass in the singleton you `concat` the `0x00` argument type, which tells the relayer that it should an expect an object type with object id of the singleton. 

You now have a template for invoking the `gmp::execute()` function.

Next, you will need to create a [transaction](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/relayer_discovery/sources/types/transaction.move) that uses the `arguments` vector you just created. 

The `new_transaction()` function call expects several parameters.

1. `is_final: bool`: For this you simply pass `true` telling the relayer to execute the transaction.
1. `move_calls: vector<MoveCall>`: A vector of [MoveCalls](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/relayer_discovery/sources/types/transaction.move#L44)

```rust
    let transaction = transaction::new_transaction(
        true,
        vector[
            transaction::new_move_call(
                transaction::new_function(
                    address::from_bytes(
                        hex::decode(
                            *ascii::as_bytes(
                                &type_name::get_address(
                                    &type_name::get<Singleton>(),
                                ),
                            ),
                        ),
                    ),
                    ascii::string(b"gmp"),
                    ascii::string(b"execute"),
                ),
                arguments,
                vector[],
            ),
        ],
    );
```

The `is_final` can simply be set to `true`. The `move_calls()` needs to receive the `function`, `arguments`, and `type_arguments` that will be triggered on that package for the object id that is being sent by the relayer. In your case the function is the `execute` function on the `gmp` module. The `arguments` are the `ApprovedMessage` object and the `singleton` you had put together previously, and the `type_arguments` can be left empty for now.


The output of this will be your new `transaction` that you can pass into the Relayer Discover's [register_transaction()](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/relayer_discovery/sources/discovery.move#L93) function along with a reference to your package's `channel` as follows: 

```rust
discovery.register_transaction(&singleton.channel, transaction);
```

Once this is called your package will be registered with the Relayer Discovery so it can begin receiving cross-chain messages.

#### Why is this needed?

In the EVM ecosystem because you inherited from AxelarExecutable, the relayer already knows your contract’s function signature and where to call it. This is because on EVM chains contracts also hold their own storage. On Sui chains package logic is separate from objects that are holding the relevant state. As a result the destination that is sent from the source chain will be the `channel_id` as opposed to the `package_id`. In other words  The package ID just tells you which code to run; the channel ID tells you where to run it and which messages to pull in



TODO finish this
{/* In the function itself you will first need to build a `vector` of arguments that contains the ABI  */}

## Deploy

TODO

## Interact With Contract

TODO