import { Callout } from "../../../../components/callout";



# Sui ITS

Axelar's [Interchain Token Service (ITS)](https://www.axelar.network/its) is live on the Sui blockchain to allow for the integration of tokens on Sui to be sent to/from [other ecosystems](https://axelarscan.io/resources/chains) connected to the Axelar Network.


The official Sui integration can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/tree/main/move/interchain_token_service)

## Overview

Interchain Token Service allow teams to deploy fresh new fungible [Interchain Tokens](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token/sources/interchain_token.move) as well as integrate custom tokens that want to go cross-chain. ITS is already live on many different EVM and non-evm chains so you can now send your Sui coins to and from those chains.

<Callout emoji="ðŸ’¡">
  The simplest way to use ITS is through Axelar's [ITS
  Portal](https://interchain.axelar.dev/), which also supports Sui! ([Testnet
  portal here](https://testnet.interchain.axelar.dev/))
</Callout>

At the package layer, ITS can be broken down into a number of key modules

1. ITS
1. Coin Management
1. Coin Info
1. Token Id
1. Storage

## ITS

This is the module that anyone would directly interact with. It needs to be able to do the following:

1. Register Coin
1. Deploy Remote Interchain Token
1. Send Interchain Transfer
1. Receive Interchain Transfer

### Register Coin

To integrate a token to ITS the `register_coin()` function must be called. This function takes in the following parameters:

1. `its`: The ITS module that will be updated once the new coin is registered
1. `coin_info`: The [coin info](#coininfo) represents the of the coin
1. `coin_management`: The type of [management](#coinmanagement) the token will have with ITS

```move
public fun register_coin<T>(
    self: &mut ITS,
    coin_info: CoinInfo<T>,
    coin_management: CoinManagement<T>,
): TokenId {
    let value = self.value_mut!(b"register_coin");

    value.register_coin(coin_info, coin_management)
}
```

Once triggered, ITS will generate a unique [token id](#tokenid) from the coin's metadata and management details. Then it will [add](https://docs.sui.io/references/framework/sui/bag#sui_bag_add) the tokenId to the `registered_coins` bag. The full implementation of the `register_coin()` function can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/v1.1.3/move/interchain_token_service/sources/versioned/interchain_token_service_v0.move#L166)

See [here](https://github.com/axelarnetwork/axelar-contract-deployments/blob/main/sui/its-example.js#L195) for an example of how to register a new coin.

### Deploy Remote Interchain Token

If you are starting from scratch and want to deploy a fresh new token with cross-chain functionality built into it, you can trigger the `deploy_remote_interchain_token()` function. This function will deploy a new *Interchain Token* on a different blockchain via a cross-chain [GMP call](https://docs.axelar.dev/dev/general-message-passing/overview/#general-message-passing). 

The function takes three parameters:

1. `its`: The ITS module that will be updated once the new coin is registered
1. `token`: The [token_id](#tokenid) representing the token to be deployed on the destination chain
1. `destination_chain`: The name of the destination chain to deploy the token on

```move
public fun deploy_remote_interchain_token<T>(
    self: &ITS,
    token_id: TokenId,
    destination_chain: String,
): MessageTicket {
    let value = self.value!(b"deploy_remote_interchain_token");

    value.deploy_remote_interchain_token<T>(token_id, destination_chain)
}
```

Since this function is making a cross-chain call, it will return a [MessageTicket](TODO) for the cross-chain transaction. The full implementation of the `deploy_remote_interchain_token()` can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/v1.1.3/move/interchain_token_service/sources/versioned/interchain_token_service_v0.move#L178).

See here for an [example](https://github.com/axelarnetwork/axelar-contract-deployments/blob/main/sui/its-example.js#L107) of how to run a cross-chain deployment for a new token.

### Interchain Transfer

Once your token has been integrated with ITS, you can use the `send_interchain_transfer()` function to actually send it cross-chain to another chain where it has been integrated. Sending an interchain transfer is a two step process. The first step is to prepare the [InterchainTransferTicket](#intercha-intransfer-ticket) via the [prepare_interchain_transfer](#prepare-interchain-transfer) function, then once the ticket is created you can trigger the [send_interchain_transfer](#send-interchain-transfer) function.


#### Prepare Interchain Transfer

This will crete the `InterchainTransferTicket` to be passed in to the `send_interchain_transfer()`

The function takes six parameters:
1. `token_id`: The id of the token being sent
1. `coin`: The actual [coin](https://docs.sui.io/standards/coin) being sent
1. `destination_chain`: The name of the chain the coin is being sent to
1. `destination_address`: The address on the destination chain the coin is being sent to
1. `metadata`: Executable data being sent along with the coin for a contract on the destination chain to handle
1. `source_channel`: The channel where the message is being sent to

```move
public fun prepare_interchain_transfer<T>(
    token_id: TokenId,
    coin: Coin<T>,
    destination_chain: String,
    destination_address: vector<u8>,
    metadata: vector<u8>,
    source_channel: &Channel,
): InterchainTransferTicket<T> {
    interchain_transfer_ticket::new<T>(
        token_id,
        coin.into_balance(),
        source_channel.to_address(),
        destination_chain,
        destination_address,
        metadata,
        VERSION,
    )
}
```

#### Send Interchain Transfer

This will trigger the cross-chain call to actually send the token from the source chain to the destination chain.

The function takes three parameters:
1. `its`: The ITS module that will be updated once the new coin is registered
1. `ticket`: The ticket of
1. `clock`: A [clock](https://docs.sui.io/references/framework/sui/clock) module that provides the time of the transfer

```move
public fun send_interchain_transfer<T>(
    self: &mut ITS,
    ticket: InterchainTransferTicket<T>,
    clock: &Clock,
): MessageTicket {
    let value = self.value_mut!(b"send_interchain_transfer");

    value.send_interchain_transfer<T>(
        ticket,
        VERSION,
        clock,
    )
}
```

See here for an [example](https://github.com/axelarnetwork/axelar-contract-deployments/blob/main/sui/its-example.js#L65) of how to use the `send_interchain_transfer()` 

The full `send_interchain_transfer()` implementation can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/versioned/interchain_token_service_v0.move#L212) 


### Receive Interchain Transfer

When tokens are sent to Sui, the [Relayer Discovery](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/discovery.move) package will trigger the `receive_interchain_transfer()` function on the Sui ITS package. 

The function takes 4 parameters: 
1. `its`: The ITS module that will be updated once the new coin is registered
1. `ticket`: The ticket of
1. `clock`: A [clock](https://docs.sui.io/references/framework/sui/clock) module that provides the time of the transfer
1. `ctx`: The [transaction context](https://docs.sui.io/references/framework/sui/tx_context#sui_tx_context_TxContext) provides the necessary runtime environment for creating or modifying objects and state

```move
public fun receive_interchain_transfer<T>(
    self: &mut ITS,
    approved_message: ApprovedMessage,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let value = self.value_mut!(b"receive_interchain_transfer");

    value.receive_interchain_transfer<T>(approved_message, clock, ctx);
}
```

Once the relayer triggers this function it in turn triggers the [give_coin()](give-coin) function on the Coin Management program. Then once `give_token()` has run the function will transfer the coin to the destination address.

The full `receive_interchain_transfer()`  can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/versioned/interchain_token_service_v0.move#L247) 


#### Receive Interchain Transfer With Data

If the source chain is sending executable metadata along with the transaction that data will be handled by the `receive_interchain_transfer_with_data()` function. 

It takes the same parameters as the previous `receive_interchain_transfer()` function except it also includes a `channel` parameter. The channel is used to check if the destination address in the payload matches the channel's own address, ensuring that messages with extra data are properly routed.

The key differences with `receive_interchain_transfer_with_data()`, are that the function `asserts` that the `data` being sent is not empty and it does not simply transfer the token to the destination address. This function is designed for transfers that carry extra information and requires additional routing and validation steps, while the standard version is for simple transfers that donâ€™t include extra data and performs the transfer immediately. It is up to the caller to decide how to transfer the coin once the function returns

```move
public fun receive_interchain_transfer_with_data<T>(
    self: &mut InterchainTokenService,
    approved_message: ApprovedMessage,
    channel: &Channel,
    clock: &Clock,
    ctx: &mut TxContext,
): (String, vector<u8>, vector<u8>, Coin<T>) {
    let value = self.value_mut!(b"receive_interchain_transfer_with_data");

    value.receive_interchain_transfer_with_data<T>(
        approved_message,
        channel,
        clock,
        ctx,
    )
}
```

See here for an [example](https://github.com/axelarnetwork/axelar-contract-deployments/blob/main/sui/its-example.js#L124) of how to receive a transfer with data.

The full `receive_interchain_transfer_with_data()` implementation can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/versioned/interchain_token_service_v0.move#L282)

## Coin Management

### Give Coin

```move
public(package) fun give_coin<T>(self: &mut CoinManagement<T>, amount: u64, clock: &Clock, ctx: &mut TxContext): Coin<T> {
    self.flow_limit.add_flow_in(amount, clock);
    if (has_capability(self)) {
        self.mint(amount, ctx)
    } else {
        coin::take(self.balance.borrow_mut(), amount, ctx)
    }
}
```

## Flow Limit



## Token Id

A `TokenId` is a unique identifier for an ITS integration. Since ITS is a permisionless service anyone can in theory integrate a deployed token, what differentiates between the potentially many different integrations of a token with ITS is the `tokenId`. 

The module for the Sui token id can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/types/token_id.move). 


## Coin Info

The coin info defines the `CoinInfo` type which stores information about a coin:

The following fields are available for CoinInfo

1. `name`: The name of the coin
1. `symbol`: The symbol of the coin
1. `decimals`: The amount of decimals the coin can hold. 
1. `metadata`: The [metadata](https://docs.sui.io/references/sui-api/sui-graphql/reference/types/objects/coin-metadata) for the coin

<Callout emoji="ðŸ’¡">
Since coins are `u64` some conversion might need to happen when receiving coins as decimals of 18 are too large for Sui to handle.
</Callout>

```move
public struct CoinInfo<phantom T> has store {
    name: String,
    symbol: ascii::String,
    decimals: u8,
    metadata: Option<CoinMetadata<T>>,
}
```


## Interchain Transfer ticket

The Interchain Transfer Ticket contains a unique type to be sent for each transfer. It contains the following fields:

1. `token_id`: The id of the token being sent cross-chain 
1. `balance`: A wrapped [balance](https://docs.sui.io/references/sui-api/sui-graphql/reference/types/objects/balance) object representing the token amount to be transferred, which is later converted to a numeric amount.
1. `source_address`: The address initiating the transfer
1. `destination_chain`: The name of the blockchain where the token is being sent to
1. `destination_address`: The receive address on the destination chain
1. `metadata`: Additional executable data to be sent with the token
1. `version`: The version of ITS that is being used for this transfer

```move
public struct InterchainTransferTicket<phantom T> {
    token_id: TokenId,
    balance: Balance<T>,
    source_address: address,
    destination_chain: String,
    destination_address: vector<u8>,
    metadata: vector<u8>,
    version: u64,
}
```