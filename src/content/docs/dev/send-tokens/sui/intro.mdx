import { Callout } from "../../../../../components/callout";

# Sui Interchain Token Service (ITS)

Axelar's [Interchain Token Service (ITS)](https://www.axelar.network/its) is live on the Sui blockchain to allow for the integration of coins on Sui to be sent to/from [other ecosystems](https://axelarscan.io/resources/chains) connected to the Axelar Network. ITS allows teams to deploy fresh new fungible [Interchain Tokens](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token/sources/interchain_token.move) as well as integrate custom tokens that want to go cross-chain. ITS is already live on many different EVM and non-evm chains, so that you can send your Sui coins to and from those chains.

The official Sui integration codebase can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/tree/main/move/interchain_token_service)

<Callout emoji="üí°">
  The simplest way to use ITS is through Axelar's [ITS
  Portal](https://interchain.axelar.dev/), which also supports Sui. The [ITS Testnet
  Portal](https://testnet.interchain.axelar.dev/).
</Callout>



## Register Coin 

To integrate a coin with Sui you must first register the coin with ITS. There are different ways to register the coin, depending on how the coin is being integrated. For canonical integrations where the coin on Sui will be connected to a wrapped interchain token on a remote chain you will register the coin on Sui via either [register_coin_from_info()](#register-coin-from-info) or [register_coin_from_metadata()](#register-coin-from-metadata). If you are connecting your Sui coin to a customized token on a different blockchain you will need to call [register_custom_coin()](#register-custom-coin), followed by [link_coin()](#link-coin).

### Register Coin From Info

If you want to register your coin by explicitly passing in its information you will need to register your coin via the `register_coin_from_info()` function. The function returns a new [TokenId](#token-id) and takes five parameters:

1. `its`: The ITS object that will be updated once the new coin is registered.
1. `name`: The name of the coin being registered.
1. `symbol`: The symbol of the coin being registered.
1. `decimals`: The amount of decimals the coin being registered has.
1. `coin_management`: The type of [management](#coin-management) the coin is registered with.

The function is defined as follows:

```rust
public(package) fun register_coin_from_info<T>(
    self: &mut InterchainTokenService,
    name: std::string::String,
    symbol: ascii::String,
    decimals: u8,
    coin_management: CoinManagement<T>,
): TokenId {}
```

This will be a commonly used registration flow as Sui coins often times [freeze](https://docs.sui.io/concepts/object-ownership/immutable#create-immutable-object) its metadata so that no one can alter critical configuration about the coin such as its name, symbol, and decimals.

### Register Coin from Metadata

If you do not want to explicitly pass in your coin's info, then you can register the coin via `register_coin_from_metadata()` function. Whereas the previous `register_coin_from_info()` may be simpler to use, this coin registration prevents against human error, for example, a typo in the symbol or name since the coin paramaters are not validated in any way. The function returns a new [TokenId](#token-id) and takes three parameters:

1. `its`: The ITS object that will be updated once the new coin is registered.
1. `metadata`: A generic reference to the coin's metadata that contains the coins name, symbol, and decimals.
1. `coin_management`: The type of [management](#coin-management) the coin is registered with.

```rust
public(package) fun register_coin_from_metadata<T>(
    self: &mut InterchainTokenService,
    metadata: &CoinMetadata<T>,
    coin_management: CoinManagement<T>,
): TokenId {}
```

The coin management must be constructed beforehand, ITS will not construct this automatically for you.

### Register Custom Coin
To integrate a coin into ITS, the `register_coin()` function must be called. This function takes in the following parameters:

1. `its`: The ITS object that will be updated once the new coin is registered
1. `coin_info`: The [coin info](#coin-info) represents the name, symbol and decimals of the coin
1. `coin_management`: The type of [management](#coin-management) the coin is registered with. 

However, before you can register your coin, you must first create a [coin-manager](#coin-management) and a [coin-info](#coin-info) for it.

```rust
public fun register_coin<T>(
    self: &mut ITS,
    coin_info: CoinInfo<T>,
    coin_management: CoinManagement<T>,
): TokenId {
    let value = self.value_mut!(b"register_coin");

    value.register_coin(coin_info, coin_management)
}
```

Once triggered, ITS will generate a unique [token id](#token-id) from the coin's metadata and management details. Then it will [add](https://docs.sui.io/references/framework/sui/bag#sui_bag_add) the tokenId to the `registered_coins` bag. The full implementation of the `register_coin()` function can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/v1.1.3/move/interchain_token_service/sources/versioned/interchain_token_service_v0.move#L166)

See [here](https://github.com/axelarnetwork/axelar-contract-deployments/blob/main/sui/its-example.js#L195) for an example of registering a new coin.

## Register Coin Metadata

The `register_coin_metadata()` function is used to register the [TokenMetadata](https://github.com/axelarnetwork/axelar-amplifier/blob/main/packages/interchain-token-service-std/src/primitives.rs#L82) msg type with [ITS Hub](/dev/amplifier/its-hub/introduction/) in order to register token data in ITS hub. This function is required to be called on each chain where you token is being integrated to ITS on if you are planning on linking a custom token. 

Note: This function is separate from [register_coin_from_metadata](#register-coin-from-metadata), which is used for registering canonical tokens for Sui.

The `register_coin_metadata()` returns a [MessageTicket](/dev/general-message-passing/sui/gmp-contracts/#message-ticket) and takes the following two parameters:

1. `its`: The ITS object that will be updated once the token's metadata is registered.
1. `coin_metadata`: The metadata of the coin to be registered.

It is written as follows:

```rust
public fun register_coin_metadata<T>(self: &InterchainTokenService, coin_metadata: &CoinMetadata<T>): MessageTicket {}
```



## Link Coin

If you are looking to connect your custom coin on Sui to a custom coin on another blockchain, such as Ethereum, you will need to *link* the coin between the two chains. The linking process can only take place after the [register_custom_coin](#register-custom-coin) function has been called. The `link_coin()` function is defined as follows:

The function takes seven parameters and returns a [MessageTicket](/dev/general-message-passing/sui/gmp-contracts/#message-ticket). 

1. `its`: The ITS object that will be updated once the new token is linked.
1. `deployer` The deployer‚Äôs [channel](/dev/general-message-passing/sui/gmp-contracts/#channel) capability. Used to derive the custom [tokenId](#token-id) with the `salt` and `chain_name`, so only that channel‚Äôs holder can link that custom token.
1. `destination_chain`: The name of the chain where the token is being linked to.
1. `destination_token_address`: The address of the token the sui coin is being linked to.
1. `token_manager_type`: The [type of manager](#coin-management) to be deployed on the destination chain.
1. `link_params`: An array of bytes representing an address to be used as the operator on the destination chain

```rust
public fun link_coin(
    self: &InterchainTokenService,
    deployer: &Channel,
    salt: Bytes32,
    destination_chain: String,
    destination_token_address: vector<u8>,
    token_manager_type: TokenManagerType,
    link_params: vector<u8>,
): MessageTicket {}
```

The complete linking token flow is as follows:

1. Deploy your custom token on each chain 
1. [Register coin metadata](#register-coin-metadata)
1. [Register custom coin on home chain](#register-custom-coin)
1. [Link coin from home chain](#link-coin)

## Deploy Remote Interchain Token

If you are starting from scratch and want to deploy a fresh new token with cross-chain functionality built into it, you can trigger the `deploy_remote_interchain_token()` function. This function will deploy a new _Interchain Token_ on a different blockchain via a cross-chain [GMP call](https://docs.axelar.dev/dev/general-message-passing/overview/#general-message-passing).

The function takes three parameters:

1. `its`: The ITS object that will be updated once the new token is registered.
1. `token`: The [token_id](#token-id) representing the token to be deployed on the destination chain.
1. `destination_chain`: The name of the destination chain to deploy the token on.

```rust
public fun deploy_remote_interchain_token<T>(
    self: &InterchainTokenService,
    token_id: TokenId,
    destination_chain: String,
): MessageTicket {
    let value = self.value!(b"deploy_remote_interchain_token");

    value.deploy_remote_interchain_token<T>(token_id, destination_chain)
}
```

Since this function makes a cross-chain call, it will return a [MessageTicket](/dev/general-message-passing/sui/gmp-contracts/#message-ticket) for the cross-chain transaction. The full implementation of the `deploy_remote_interchain_token()` can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/v1.1.3/move/interchain_token_service/sources/versioned/interchain_token_service_v0.move#L178).

See here for an [example](https://github.com/axelarnetwork/axelar-contract-deployments/blob/main/sui/its-example.js#L107) of how to run a cross-chain deployment for a new coin.

## Interchain Transfer

Once your coin has been integrated with ITS, you can use the `send_interchain_transfer()` function to send it cross-chain to another chain where it has been integrated. Sending an interchain transfer is a two-step process.

The first step is to prepare the [Interchain Transfer Ticket](#interchain-ransfer-ticket) via the [prepare_interchain_transfer](#prepare-interchain-transfer) function. Once the ticket is created, you can trigger the [send_interchain_transfer](#send-interchain-transfer) function. Breaking up the transfer into a two-step process allows the package to be more flexible in the case of an upgrade.



<Callout emoji="üí°">
Other functions that return `MessageTickets` in ITS include:

- `link_coin()`
- `register_coin_metadata()`
- `deploy_remote_interchain_token()`
- `send_interchain_transfer()`
</Callout>


### Prepare Interchain Transfer

This will create the `InterchainTransferTicket` to be passed into the `send_interchain_transfer()`

The function takes six parameters:

1. `token_id`: The id of the coin being sent.
1. `coin`: The actual [coin](https://docs.sui.io/standards/coin) being sent.
1. `destination_chain`: The name of the chain the coin is being sent to.
1. `destination_address`: The address on the destination chain the coin is being sent to.
1. `metadata`: Executable data being sent along with the coin for a contract on the destination chain to handle.
1. `source_channel`: The [channel](/dev/general-message-passing/sui/gmp-contracts/#channel) where the message is being sent to. This channel will serve as the source address for the transaction on the destination chain.

```rust
public fun prepare_interchain_transfer<T>(
    token_id: TokenId,
    coin: Coin<T>,
    destination_chain: String,
    destination_address: vector<u8>,
    metadata: vector<u8>,
    source_channel: &Channel,
): InterchainTransferTicket<T> {
    interchain_transfer_ticket::new<T>(
        token_id,
        coin.into_balance(),
        source_channel.to_address(),
        destination_chain,
        destination_address,
        metadata,
        VERSION,
    )
}
```


### Why Prepare Interchain Transfer is Necessary?

In EVM upgradability on the other hand, smart contracts are replaced atomically. This means that when you upgrade a contract, the proxy automatically knows that it should make a `delegatecall` to a new implementation (as the upgrade comes from swapping in a new implementation at the proxy's storage slot, making the old implementation unreachable). This means that when a package is upgraded, the shared objects created by the old package continue to exist and retain their original data structures, even as new package versions are deployed. Unlike EVM where a proxy immediately redirects all calls to the new implementation, Sui objects must explicitly manage which version of the package logic should handle their operations.

If ITS were to get updated to a new version, the ITS object itself upgrades to the new version, but tickets created before the upgrade still exist with their old version stamps. To ensure backwards compatibility and prevent version mismatches, the `prepare_interchain_transfer()` function creates a `ticket` with a version stamp indicating which version of ITS was active when the ticket was created. When `send_interchain_transfer()` processes the ticket, it can check the version compatibility and either:

1. Process the ticket with v0-compatible logic if it's an old ticket
1. Process it with v1 logic if it's a new ticket
1. Reject it if the ticket is from a newer version than the current ITS

### Send Interchain Transfer

With the ticket now created, you can use it with the `send_interchain_transfer()` function. Once called, `send_interchain_transfer()` will trigger the cross-chain call to send the coin from the source chain to the destination chain.

The function takes three parameters:

1. `its`: The ITS object that will be updated once the new coin is registered.
1. `ticket`: The [ticket](#interchain-transfer-ticket) representing the coin transfer.
1. `clock`: A [clock](https://docs.sui.io/references/framework/sui/clock) module that provides the time of the transfer.

```rust
public fun send_interchain_transfer<T>(
    self: &mut InterchainTokenService,
    ticket: InterchainTransferTicket<T>,
    clock: &Clock,
): MessageTicket {
    let value = self.value_mut!(b"send_interchain_transfer");

    value.send_interchain_transfer<T>(
        ticket,
        VERSION,
        clock,
    )
}
```

See here for an [example](https://github.com/axelarnetwork/axelar-contract-deployments/blob/main/sui/its-example.js#L65) of how to use the `send_interchain_transfer()`

The full `send_interchain_transfer()` implementation can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/versioned/interchain_token_service_v0.move#L212)

## Receive Interchain Transfer

When tokens are sent to Sui, the [Relayer Discovery](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/discovery.move) module triggers the `receive_interchain_transfer()` function on the Sui ITS module. An application must register with the `relayer_discovery` and use a `channel` they control as the destination address to receive tokens with data.

The function takes four parameters:

1. `its`: The ITS object that will be updated once the new coin is registered.
1. `approved_message`: The cross-chain [message](/dev/general-message-passing/sui/sui-programs/#approvedmessage) sent with the receiving instructions for the coin.
1. `clock`: A [clock](https://docs.sui.io/references/framework/sui/clock) module that provides the time of the transfer.
1. `ctx`: The [transaction context](https://docs.sui.io/references/framework/sui/tx_context#sui_tx_context_TxContext) provides the necessary runtime environment for creating or modifying objects and state.

```rust
public fun receive_interchain_transfer<T>(
    self: &mut InterchainTokenService,
    approved_message: ApprovedMessage,
    clock: &Clock,
    ctx: &mut TxContext,
) {
    let value = self.value_mut!(b"receive_interchain_transfer");

    value.receive_interchain_transfer<T>(approved_message, clock, ctx);
}
```

Once the relayer triggers this function, it, in turn, triggers the [give_coin](#give-coin) function on the Coin Management program. Once `give_coin()` has run, the function will transfer the coin to the destination address.

The full `receive_interchain_transfer()` can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/versioned/interchain_token_service_v0.move#L247)

### Receive Interchain Transfer With Data

If the source chain sends executable metadata along with the transaction, the `receive_interchain_transfer_with_data()` function will handle that data.

It takes the same parameters as the previous `receive_interchain_transfer()` function, except it also includes a `channel` parameter. The channel checks if the payload's destination address matches the channel's address, ensuring that messages with extra data are correctly routed.

For the channel to be available, the package must be registered with `relayer_discovery` and use a `channel` they control as the destination address.

The key difference with `receive_interchain_transfer_with_data()` is that the function `asserts` that the `data` being sent is not empty and does not simply transfer the coin to the destination address. This function is designed for transfers that carry extra information and require additional routing and validation steps, while the standard version is for simple transfers that don't include extra data and perform the transfer immediately. It is up to the caller to decide how to transfer the coin once the function returns.

```rust
public fun receive_interchain_transfer_with_data<T>(
    self: &mut InterchainTokenService,
    approved_message: ApprovedMessage,
    channel: &Channel,
    clock: &Clock,
    ctx: &mut TxContext,
): (String, vector<u8>, vector<u8>, Coin<T>) {
    let value = self.value_mut!(b"receive_interchain_transfer_with_data");

    value.receive_interchain_transfer_with_data<T>(
        approved_message,
        channel,
        clock,
        ctx,
    )
}
```

See here for an [example](https://github.com/axelarnetwork/axelar-contract-deployments/blob/main/sui/its-example.js#L124) of how to receive a transfer with data.

The full `receive_interchain_transfer_with_data()` implementation can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/versioned/interchain_token_service_v0.move#L282)

## Coin Management

A centerpiece of the ITS design is the [Coin Management](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/types/coin_management.move) module (akin to the [token manager](/dev/send-tokens/interchain-tokens/token-manager/) contract for EVM chains). The `Coin Management` module facilitates integrating the `coin` and `ITS`. It is created before registering a coin. It encapsulates key functionalities such as minting, burning, managing balances, and enforcing [flow limits](#flow-limit) for cross‚Äêchain operations. 

Coin managers can be initialized as either a [capped](#capped-management) manager or [locked](#locked-management). The module stores the following fields:

1. `treasury_cap`: An optional [capability](https://docs.sui.io/standards/coin#treasury-capability) that, if present, allows minting and burning of coins.
1. `balance`: An optional balance used when managing locked coins (i.e., already in circulation).
1. `distributor`: An optional address authorized for minting and burning operations.
1. `operator`: An optional address authorized to set flow limits for the coin.
1. `flow_limit`: A structure that tracks coins' allowed inflow and outflow to control their movement.
1. `dust`: A field (type u256) tracking leftover coins after transfers.

```rust
public struct CoinManagement<phantom T> has store {
    treasury_cap: Option<TreasuryCap<T>>,
    balance: Option<Balance<T>>,
    distributor: Option<address>,
    operator: Option<address>,
    flow_limit: FlowLimit,
    dust: u256,
}
```

A coin management object must be created before the coin is registered with ITS. 

### Capped Management

Capped Management types create a new `CoinManagement` with a [Treasury Cap](https://docs.sui.io/standards/coin#treasury-capability). This type of `CoinManagement` allows the minting and burning of coins, meaning when the coin is sent out of Sui, it is burned, and when it is sent back into Sui, it is minted. This is a valuable manager type if your coin is natively integrated into a number chain. In other words, when there is no canonical implementation of the coin on a single chain on which all other coins depend, Integrating a `capped` manager type involves calling the following factory function.

```rust
public fun new_with_cap<T>(treasury_cap: TreasuryCap<T>): CoinManagement<T> {
    CoinManagement<T> {
        treasury_cap: option::some(treasury_cap),
        balance: option::none(),
        distributor: option::none(),
        operator: option::none(),
        flow_limit: flow_limit::new(),
        dust: 0,
    }
}
```

See [here](https://github.com/axelarnetwork/axelar-contract-deployments/blob/main/sui/its-example.js#L201) for an example of deploying new capped managers.

### Locked Management

Locked Management types Create a new `CoinManagement` with a `Balance`. The stored `Balance` can be used to take and put coins. This manager type will lock the sent coin with ITS when the coin is sent out of Sui and unlock the coin when it is sent back into the Sui ecosystem. This type of manager is very useful if Sui is the _home-chain_ for your ITS integration and you use wrapped coins on other chains that derive back to the canonical coin on Sui. Integrating the ` new_locked` manager type involves calling the following factory function.

```rust
public fun new_locked<T>(): CoinManagement<T> {
    CoinManagement<T> {
        treasury_cap: option::none(),
        balance: option::some(balance::zero()),
        distributor: option::none(),
        operator: option::none(),
        flow_limit: flow_limit::new(),
        dust: 0,
    }
}
```

See [here](https://github.com/axelarnetwork/axelar-contract-deployments/blob/main/sui/its-example.js#195) for an example of deploying a new locked manager.

### Give Coin

The Management module triggers the `give_coin()` function when the coin is sent into the Sui ecosystem. This function updates the incoming [flow limit](#flow-limit) and then either mints new coins (if the instance has a [treasury capability](https://docs.sui.io/standards/coin#treasury-capability)) or withdraws coins from the internal balance. It returns the coin object that is ready to be transferred.

```rust
public(module) fun give_coin<T>(self: &mut CoinManagement<T>, amount: u64, clock: &Clock, ctx: &mut TxContext): Coin<T> {
    self.flow_limit.add_flow_in(amount, clock);
    if (has_capability(self)) {
        self.mint(amount, ctx)
    } else {
        coin::take(self.balance.borrow_mut(), amount, ctx)
    }
}
```

### Take Balance

When the coin is out of the Sui ecosystem, the Management module will trigger the `take_balance()` function. This function updates the [flow limit](#flow-limit) for an outgoing transfer and then either burns the coins (if the minting capability is available) or merges the deducted amount into the stored balance. It returns the numeric amount (as a `u64`) taken.

```rust
public(package) fun take_balance<T>(self: &mut CoinManagement<T>, to_take: Balance<T>, clock: &Clock): u64 {
    self.flow_limit.add_flow_out(to_take.value(), clock);
    let amount = to_take.value();
    if (has_capability(self)) {
        self.burn(to_take);
    } else {
        self.balance.borrow_mut().join(to_take);
    };
    amount
}
```

### Set Flow Limit

To set a specific [flow limit](#flow-limit) amount, trigger the `set_flow_limit_as_token_operator()` function.

The function takes four parameters:

1. `self`: The module that will be updated once the `flow_limit` is set.
1. `channel`: A reference to the `Channel` object to derive the caller's address. The address is checked to ensure that only the authorized operator can change the `flow_limit`.
1. `token_id`: The [token id](#token-id) representing the token to be set.
1. `limit`: An optional unsigned 64-bit integer representing the new flow limit.

```rust
public fun set_flow_limit_as_token_operator<T>(
    self: &mut InterchainTokenService,
    channel: &Channel,
    token_id: TokenId,
    limit: Option<u64>,
) {}
```

Note: A flow limit of `0` corresponds to no flow limit set at all. If you wish to remove your flow limit it should be set to 0. To halt transfers of your coin in/out of Sui you can set the flow limit to a near `0` value, effectively halting cross-chain transfers.

## Roles

The Coin Management module has set roles that can handle specific functionality.

### Distributor

An address set within the CoinManagement instance that is authorized to perform minting/burning operations. Only CoinManagement instances with a [treasury capability](https://docs.sui.io/standards/coin#treasury-capability) can add a distributor. 

#### Add Distributor

The `add_distributor()` function in the [Coin Management package](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/types/coin_management.move) takes two parameters:

1. `self`: The module that will be updated once the `distributor` is set.
1. `distributor`: The address of the `distributor` to be set. The address that is added should be an [address](https://docs.sui.io/references/sui-api/sui-graphql/reference/types/objects/address) type of your Channel.

```rust
public fun add_distributor<T>(self: &mut CoinManagement<T>, distributor: address) {
    assert!(self.has_treasury_cap(), EDistributorNeedsTreasuryCap);
    self.distributor.fill(distributor);
}
```

The `add_distributor()` function must be called before the coin is [registered](#register-coin). This function can be called by the address that  owns a [Coin Management](#coin-management). However, once the coin is registered with ITS this function is no longer callable as ownership of the `Coin Management` object (which in turn owns the `Distributor` object) is passed to ITS itself. If in the future you wish to change the `Distributor` that was set before the coin was registered, you can transfer the `Distributor` with the [transfer distributor](#transfer-distributor) function.


#### Transfer Distributor

After registration, CoinManagement is owned by ITS and `add_distributor()` is no longer callable. To change/remove the distributor, call `transfer_distributorship()`. This succeeds only if `current_distributor_channel.to_address()` matches the stored distributor.

The function takes four parameters:

1. `self`: The module that will be updated once the `distributor` is set.
1. `channel`: The channel that is able to update the `distributor`.
1. `token_id`: The id of the coin that will receive the new operator.
1. `new_distributor`: The address of the new `distributor` to be set. 

```rust
public(package) fun transfer_distributorship<T>(
    self: &mut InterchainTokenService_v0,
    channel: &Channel,
    token_id: TokenId,
    new_distributor: Option<address>,
) {}
```


### Operator

An address authorized to update [flow limits](#flow-limit) for coin transfers. When setting a new flow limit, the module verifies that the caller's channel address matches the stored operator address to ensure only the operator can make that change. An operator can be registered by triggering the `add_operator()` function.


#### Add Operator

The `add_operator()` function defined in the [Coin Management package](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/types/coin_management.move) takes two parameters:

1. `self`: The module that will be updated once the `operator` is set.
1. `operator`: The address of the `operator` to be set. The address that is added should be an [address](https://docs.sui.io/references/sui-api/sui-graphql/reference/types/objects/address) type of your Channel.

It is defined as follows:

```rust
public fun add_operator<T>(self: &mut CoinManagement<T>, operator: address) {
    self.operator.fill(operator);
}
```

The `add_operator()` function must be called before the coin is [registered](#register-coin). This function can be called by the address that has created the [Coin Management](#coin-management) object. However, once the coin is registered with ITS this function is no longer callable as ownership of the `Coin Management` object (which in turn owns the `Operator` object) is passed to ITS itself. If in the future you wish to change the `Operator` that was set before the coin was registered, you can transfer the `Operator` with the [transfer operator](#transfer-operator) function.

#### Transfer Operator

The `transfer_operatorship()` function takes four parameters:

1. `self`: The module that will be updated once the new `operator` is set.
1. `channel`: The channel that is able to update the `operator`.
1. `token_id`: The id of the coin that will receive the new `operator`.
1. `new_operator`: The address of the new `operator` to be set. 


```rust
public fun transfer_operatorship<T>(
    self: &mut InterchainTokenService,
    channel: &Channel,
    token_id: TokenId,
    new_operator: Option<address>,
) {}
```


## Flow Limit

A [Flow Limit](/dev/send-tokens/interchain-tokens/flow-limit/) represents the volume of a coin that can be transferred in/out of Sui via ITS. This limit plays a critical role in maintaining network integrity and security. When coins are sent out of Sui. The flow limit logic can be found in its own [Flow Limit Module](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/types/flow_limit.move). The duration of a `flow_limit` is set to an `epoch`. An `epoch` lasts for six hours. It is calculated as follows:

```rust
const EPOCH_TIME: u64 = 6 * 60 * 60 * 1000;
```

The module has several pieces of functionality that are triggered by the [Coin Management](#coin-management) module.

### Add Flow In

This is triggered each time the `give_coin()` function is executed. It increments the `flow_in` value to track when the `flow_limit` is reached.

```rust
public(package) fun add_flow_in(self: &mut FlowLimit, amount: u64, clock: &Clock) {
    if (self.flow_limit.is_none()) {
        return
    };
    let flow_limit = *self.flow_limit.borrow() as u128;

    update_epoch(self, clock);
    assert!(self.flow_in + (amount as u128) < flow_limit + self.flow_out, EFlowLimitExceeded);
    self.flow_in = self.flow_in + (amount as u128);
}
```

### Add Flow Out

This is triggered each time the `take_balance()` function is executed. It increments the `flow_out` value to track when the `flow_limit` is reached.

```rust
public(package) fun add_flow_out(self: &mut FlowLimit, amount: u64, clock: &Clock) {
    if (self.flow_limit.is_none()) {
        return
    };
    let flow_limit = *self.flow_limit.borrow() as u128;

    update_epoch(self, clock);
    assert!(self.flow_out + (amount as u128) < flow_limit + self.flow_in, EFlowLimitExceeded);
    self.flow_out = self.flow_out + (amount as u128);
}
```

## Token Id

A `tokenId` is a unique identifier for an ITS integration. Since ITS is a permissionless service, anyone can, in theory, integrate a deployed coin. The `tokenId` differentiates between the potentially many different integrations of a coin with ITS.

The module for the Sui coin id can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/interchain_token_service/sources/types/token_id.move).

A `TokenId` is a wrapper of a coin's address.

```rust
public struct TokenId has a copy, drop, store {
id: address,
}

```

## Coin Info

The coin info defines the `CoinInfo` type, which stores information about a coin:

The following fields are available for CoinInfo

1. `name`: The name of the coin.
1. `symbol`: The symbol of the coin.
1. `decimals`: The amount of decimals the coin can hold.
1. `metadata`: The [metadata](https://docs.sui.io/references/sui-api/sui-graphql/reference/types/objects/coin-metadata) for the coin.

<Callout emoji="üí°">
  Since coins are `u64,` some conversion might need to happen when receiving
  coins, as decimals of 18 are too large for Sui to handle.
</Callout>

```rust
public struct CoinInfo<phantom T> has store {
    name: String,
    symbol: ascii::String,
    decimals: u8,
    metadata: Option<CoinMetadata<T>>,
}
```

You can run one of two factory functionalities to create a new Coin Info module for your coin.

### From Info

This will create new Coin Info based on the given name, symbol, and decimals. The selection alongside the coin type will result in a unique `TokenId`.

```rust
public fun from_info<T>(name: String, symbol: ascii::String, decimals: u8): CoinInfo<T> {
    CoinInfo {
    name,
    symbol,
    decimals,
    metadata: option::none(),
    }
}

```

An example of how to register a new Coin Info with `from_info()` can be found [here](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/example/sources/its/its.move#L141)

### From Metadata

This will create a new coin info from the given `CoinMetadata` object. This can only be done once per coin since there is only one CoinMetadata per Coin.

```rust
public fun from_metadata<T>(metadata: CoinMetadata<T>): CoinInfo<T> {
    CoinInfo {
        name: metadata.get_name(),
        symbol: metadata.get_symbol(),
        decimals: metadata.get_decimals(),
        metadata: option::some(metadata),
    }
}
```

## Interchain Transfer Ticket

The Interchain Transfer Ticket contains a unique type to be sent for each transfer, holding all the info required for an interchain transfer. It includes the following fields:

1. `token_id`: The id of the coin being sent cross-chain.
1. `balance`: A wrapped [balance](https://docs.sui.io/references/sui-api/sui-graphql/reference/types/objects/balance) object representing the coin amount to be transferred, which is later converted to a numeric amount.
1. `source_address`: The address initiating the transfer.
1. `destination_chain`: The name of the blockchain where the coin is being sent to.
1. `destination_address`: The receive address on the destination chain.
1. `metadata`: Additional executable data to be sent with the coin.
1. `version`: The version of ITS that is being used for this transfer.

```rust
public struct InterchainTransferTicket<phantom T> {
    token_id: TokenId,
    balance: Balance<T>,
    source_address: address,
    destination_chain: String,
    destination_address: vector<u8>,
    metadata: vector<u8>,
    version: u64,
}

```

To create an `InterchainTransferTicket,` you can trigger the `prepare_interchain_transfer_ticket()` on ITS.

```rust
public fun prepare_interchain_transfer<T>(
    token_id: TokenId,
    coin: Coin<T>,
    destination_chain: String,
    destination_address: vector<u8>,
    metadata: vector<u8>,
    source_channel: &Channel,
): InterchainTransferTicket<T> {
    interchain_transfer_ticket::new<T>(
        token_id,
        coin.into_balance(),
        source_channel.to_address(),
        destination_chain,
        destination_address,
        metadata,
        VERSION,
    )
}
```