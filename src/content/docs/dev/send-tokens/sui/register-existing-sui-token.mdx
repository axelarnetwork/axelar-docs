import { Callout } from "../../../../../components/callout";


# Register Existing Sui Token With Interchain Token Service


This guide demonstrates, step-by-step, how to use [Axelar's Interchain Token Service (ITS)](/dev/send-tokens/interchain-tokens/intro/#interchain-token-service) to register an existing token on Sui and make it available for cross-chain transfers.

By the end, you will be able to:

1. Register an existing token on Sui with Axelar ITS.
1. Deploy that token representation on an EVM chain (Avalanche Fuji testnet).
1. Transfer tokens seamlessly between Sui and the EVM chain.

## Prerequisites

Before starting, make sure you have the following ready:

- Rust installed with the wasm32 target enabled ([installation instructions](https://www.rust-lang.org/tools/install))
- A Sui testnet account funded with testnet tokens
- The [Sui CLI](https://docs.sui.io/references/cli/client) installed and configured
- A browser wallet like [Slush Wallet](https://chromewebstore.google.com/detail/slush-%E2%80%94-a-sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil) to connect to Sui testnet.




## Part 1: Understanding the Interchain Token Service

The [Interchain Token Service (ITS)](https://github.com/axelarnetwork/axelar-cgp-sui/tree/main/move/interchain_token_service) is a protocol that allows tokens to move freely between different blockchains.

ITS allows you to register existing tokens you own on Sui and seamlessly transfer their value across chains. It achieves this through a canonical token integration, meaning:

- When you transfer your Sui token to another chain, ITS _locks_ the token on Sui
- It _mints_ a corresponding wrapped token on the destination chain
- When tokens move back to Sui, the wrapped tokens are _burned_ and the original tokens are _unlocked_

<Callout emoji="üí°">
  There can only be a single lock/unlock token manager for the token
</Callout>

## Part 2: Set up your Sui ITS project

To setup a new Sui project run the command:
```bash
sui move new its_demo
```

Among other items, this will create a `sources` folder and `move.toml` file. The `sources` folder will contain the Sui Move code for your ITS project, and the `move.toml` file will contain the configuration for your project.

The three key configurations for your `move.toml` file are 

1. The package - The name of your package being deployed.
1. The dependencies - The dependencies your package has on other Move packages.
1. The addresses - The address is a spot for a human readable address of the where the package is deployed.

The completed `move.toml` file should look like this:

```toml
[package]
name = "my_coin"
edition = "2024.beta" # edition = "legacy" to use legacy (pre-2024) Move

[dependencies]
Sui = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }

[addresses]
my_coin = "0x0" #0x0 is a placeholder for a package not yet deployed.
```

## Part 3: Deploy Sui Token

This part can be skipped if you already have a Sui token deployed. For the sake of this demo we will use a very straightforward token implementation on the Sui testnet. Worth noting that although this token is simple ITS is able to handle much more robust custom token implementations as well.

We will use the token example straight the official [Sui documentation](https://docs.sui.io/guides/developer/coins). 

The coin has the ability to `drop` (burn) and `mint` coins. In it's `init` function it creates a treasury cap and metadata for the coin, and transfers the initial supply to the sender. When dealing with Sui coins a [treasury cap](https://docs.sui.io/standards/coin#treasury-capability) is used to grant permission to mint additional coins. A coin's [metadata](https://docs.sui.io/references/sui-api/sui-graphql/reference/types/objects/coin-metadata) corresponds to an object that contains information about the token, such as its name, symbol, and decimals.

Once the token is created the rest of the `init` function will freeze the metadata so that anyone can alter this vital information about the token once it's deployed. Finally, the `treasury cap` object is transferred to the deployer, giving them sole ability to mint new tokens.

The `mint()` function allows the owner of the treasury cap to mint new tokens and transfer them to a specified recipient.

```rust
// Declare module
module my_coin::my_custom_coin;

// Import necessary modules
use sui::coin::{Self, TreasuryCap};

//move resource type
public struct MY_CUSTOM_COIN has drop {}

fun init(witness: MY_CUSTOM_COIN, ctx: &mut TxContext) {
    let (treasury, metadata) = coin::create_currency(
        witness,
        6,
        b"MCC",
        b"My Custom Token",
        b"",
        option::none(),
        ctx,
    );
	//make metadata immutable
    transfer::public_freeze_object(metadata);
	//transfer initial supply to sender
    transfer::public_transfer(treasury, ctx.sender())
}


public fun mint(
    treasury_cap: &mut TreasuryCap<MY_CUSTOM_COIN>,
    amount: u64,
    recipient: address,
    ctx: &mut TxContext,
) {
    let coin = coin::mint(treasury_cap, amount, ctx);
    transfer::public_transfer(coin, recipient)
}
```


At this point you should be able to compile your token. This can be done by running  

```bash
sui move build
```

Great! At this point you now have a compiled Sui token. Before being able to integrate it to ITS you will need to deploy the token to the Sui testnet first.


## Part 4: Deploy Sui Token

Sui allows you to deploy Move packages via the [Sui CLI](https://intro.sui-book.com/unit-one/lessons/5_contract_deployment.html#deploying-the-contract). Although this would work, this document will use Mysten's [JavaScript SDK](https://intro.sui-book.com/unit-one/lessons/5_contract_deployment.html#deploying-the-contract) to deploy the token and interact with deployed packages.

Before building out the deployment script you will need to install the following packages. 

```bash
npm i commander dotenv @mysten/sui @axelar-network/axelar-cgp-sui
```

You can create a new file to run the script by running the following command:

```bash
mkdir scripts
touch scripts/deploy.js
```

With your packages now installed you can import the neccessary modules into your `deploy.js` file.


```javascript
import { execSync } from 'child_process'
import { Command } from 'commander'
import { Transaction } from '@mysten/sui/transactions'
```

You can setup your execution environment for your script as follows

```javascript
async function run() {}

const program = new Command()
program.description('Deploy Sui Coin').action(async () => {
  try {
    await run()
  } catch (err) {
    console.error('‚ùå Error:', err.message || err)
    process.exit(1)
  }
})

program.parse(process.argv)
```

#### Get Wallet Helper

To interact with the Sui testnet you will need to connect to a wallet. The following function will help you connect to your wallet and return the connected wallet address. You can do this in a separate `utils` file

```bash
mkdir utils
touch utils/index.js
```

Then in your utils you can write the functionality to connect to your wallet.

```javascript
import { ethers } from 'ethers';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { SuiClient } from '@mysten/sui/client';
import 'dotenv/config';

async function getWallet() {
    const client = new SuiClient({ url: 'https://fullnode.testnet.sui.io:443' });

    const rawKey = process.env.PRIVATE_KEY;

    if (!rawKey) {
        console.error('PRIVATE_KEY not set in your .env');
        process.exit(1);
    }

    const keypair = Ed25519Keypair.fromSecretKey(rawKey);
    return [keypair, client];
}
```

For this function to work you must add your private key to a `.env` file in the root of your project. 

The `getWallet` function will return a keypair and a client that you can use to interact with the Sui testnet.


With the `getWallet()` function now built out you can return back the deployment script. 

In you `run()` function you can trigger the `getWallet()` function

```javascript
async function run() {
  const [keypair, client] = await getWallet();
  const address = keypair.getPublicKey().toSuiAddress();
}
```

Next, you can run the `build` command we ran previously but in the script so you do not need to build each time in the cli. This can be done as follows

```javascript
const buildOutput = execSync(`sui move build --dump-bytecode-as-base64`, {
encoding: 'utf-8',
})
```

The `--dump-bytecode-as-base64` flag tells sui move build to emit a JSON blob on stdout.

With the package now built you can move on to [publishing](https://docs.sui.io/guides/developer/first-app/publish) it on chain.

To do this you need to create a new [Transaction](https://sdk.mystenlabs.com/typescript/transaction-building/basics) object. Then you can run the `publish` to get the instructions publish the package on chain.  This can be done as follows

```javascript
  const tx = new Transaction()
  const [upgradeCap] = tx.publish({ modules, dependencies })

  tx.transferObjects([upgradeCap], myAddress)

  console.log('üöÄ Sending publish transaction‚Ä¶')
```

The `transferObject` function transfers the [upgrade capability](https://docs.sui.io/concepts/sui-move-concepts/packages/upgrade) to the deployer address. To execute on chain you can run the `signAndExecuteTransaction` function as follows from the Sui Client. This function will be signed by your keypair that you previously generated and pass in the `tx` object which contains the `publish` instructions. It can be written as follows:

```javascript
  const response = await client.signAndExecuteTransaction({
    signer: keypair,
    transaction: tx,
    options: { showObjectChanges: true },
  })
  console.log('‚úÖ Publish succeeded!')
```

TODO note on `showObjectChanges`


The final thing to do is to return the relevant objects that will be contained in the transaction response object. This can be done as follows

 
```javascript
// Extract published package ID
  const publishedChange = response.objectChanges.find(
    (c) => c.type === 'published'
  )

  const treasuryChange = response.objectChanges.find(
    (c) =>
      c.type === 'created' && c.objectType.startsWith('0x2::coin::TreasuryCap')
  )

  const packageId = publishedChange?.packageId
  console.log('üì¶ Published package ID:', packageId)

  const treasuryCapId = treasuryChange.objectId
  console.log('üí∞ Treasury cap:', treasuryCapId)
```

To run the deployment you can run

```bash
node scripts/deploy.js
```

The output should be similar to the following:

```bash
node scripts/deploy.js
üì¶ Building Move package
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING my_coin
üöÄ Sending publish transaction‚Ä¶
‚úÖ Publish succeeded!
üì¶ Published package ID: 0x129245163917fd5ec0a90ad83216ca1380ddb37ccbd2be246f62e905f78c88a7
üí∞ Treasury cap: 0xde83787facc01740a8c0d670ada99364395d4d9a127a723f62316238da2db671
```


Great at this point you should now have a completed the deployment of your token. You can compare that your repo matches with [Checkpoint 4](TODO)

## Part 5: Mint Token

With the token now deployed you will need to `mint` some tokens before being able to actually send a cross-chain transfer. If you are familiar with minting Sui coins feel free to skip this section.

To create a new script to mint tokens you can run the following command:

```bash
touch scripts/mint.js
```  

You can create the starter code for the mint script similar to the deployments script. This time however the script will require arguments to be passed in.

The required arguments for the script are

1. `coinPackageId` - The package ID of the coin you deployed.
1. `treasury` - The treasury cap ID of the coin you deployed.

You should have both of these values in the logs after running the previous script.

```javascript
import { Command } from 'commander'
import { Transaction } from '@mysten/sui/transactions'
import { getWallet } from '../utils/index.js'

async function run(args) {}


const program = new Command()
program
  .description('Mint Sui Coin')
  .requiredOption('--coinPackageId <coinPackageId>', 'Coin Package Id')
  .requiredOption('--treasury <treasury>', 'Treasury')
  .action(async (opts) => {
    try {
      await run(opts)
    } catch (err) {
      console.error('‚ùå Error:', err.message || err)
      process.exit(1)
    }
  })

program.parse(process.argv)
```

You can then begin to writeup the logic in the `run()` function, similarly to how you did in the previous script, starting off with the `getWallet()` function and creating a new `Transaction` object.

```javascript
  const [keypair, client] = getWallet()
  const myAddress = keypair.getPublicKey().toSuiAddress()
  const mintTx = new Transaction()
```

As a reminder, the `mint()` function on the Sui token takes in the following parameters:

1. `treasury_cap` - The treasury cap object that allows minting.
1. `amount` - The amount of tokens to mint.
1. `recipient` - The address to send the minted tokens to.
1. `ctx` - The transaction context.

```rust
public fun mint(
    treasury_cap: &mut TreasuryCap<MY_CUSTOM_COIN>,
    amount: u64,
    recipient: address,
    ctx: &mut TxContext,
) {}
```

To call the `mint()` function you will need to use the [moveCall](https://sdk.mystenlabs.com/typedoc/classes/_mysten_sui.transactions.Transaction.html#movecall) function on the `Transaction` object from Sui's SDK. The `moveCall`  executes a Move call and returns whatever the Sui Move call returns.

Back in the `mint` script in your `run()` function you can create a `move call` as follows:

It requires the first three params from the token's package to be passed in (the context will be injected by the Move VM)

```javascript
  mintTx.moveCall({
    target: `${coinPackageId}::my_custom_coin::mint`,
    arguments: [
      mintTx.object(treasury), // the cap you extracted
      mintTx.pure.u64(1), // BigInt for u64
      mintTx.pure.address(myAddress), // Sui address of the recipient
    ],
  })
```

With the `moveCall` added in must now broadcast the transaction to Sui by running the `signAndExecuteTransaction` as you did before in the deployment script.

```javascript
  await client.signAndExecuteTransaction({
    signer: keypair,
    transaction: mintTx,
  })
```

Lastly, you can query the balance of your coin to ensure that the mint was successful. This can be done by running the `getBalance` function from the Sui SDK.

Unlike with the `mint()` you do not need to make a `moveCall` to query the balance, as no state change is being made to Sui. Instead, you can directly call the `getBalance` function on the client object. This will hits the node‚Äôs `JSON-RPC` endpoint (the [sui_getBalance](https://www.quicknode.com/docs/sui/suix_getBalance) RPC method) which will return whatever the node has indexed for your address and coin type.


```javascript
  const balance = await client.getBalance({
    owner: myAddress,
    coinType: `${coinPackageId}::my_custom_coin::MY_CUSTOM_COIN`,
  })

  console.log('üí∞ Minted successfully! New balance:', balance)
```

You can execute the `mint` script by running the following command:

```bash
node scripts/mint.js --coinPackageId 0x129245163917fd5ec0a90ad83216ca1380ddb37ccbd2be246f62e905f78c88a7 --treasury 0xde83787facc01740a8c0d670ada99364395d4d9a127a723f62316238da2db671
```

If successful you should see an output similar to the following:

```bash
üöÄ Sending mint transaction‚Ä¶
üí∞ my token balance 1
```

Great! At this point you should be able to deploy a new token, mint and confirm the balance has increased. You can compare that your repo matches with [Checkpoint 5](TODO)

## Part 6: Register Token with ITS

With your token now live you can begin the process of registering it with ITS. This will allow you to transfer the token across chains using Axelar's Interchain Token Service.

This will also be done via an integration script, you can create the script as follows:

```bash
touch scripts/integrateAxelar.js
``` 

Then create the standard script boilerplate as you did in the previous scripts.

```javascript
import { Command } from 'commander'
import { Transaction } from '@mysten/sui/transactions'
import { getWallet } from '../utils/index.js'



async function run(args) {}


const registerCoinCommand = new Command()
registerCoinCommand
  .description('Register Sui coin with ITS')
  .requiredOption('--coinPackageId <coinPackageId>', 'Coin Package Id')
  .action(async (opts) => {
    try {
      await run(opts)
    } catch (err) {
      console.error('‚ùå Error:', err.message || err)
      process.exit(1)
    }
  })

registerCoinCommand.parse(process.argv)
```

This script will only require the `coinPackageId` as an argument, as the treasury cap is not required to register the token with ITS.

In your `run()` function you can then destructure the passed in argument, get your keypair, and create a new `Transaction` object as you did in the previous script.

```javascript
  const { coinPackageId } = args
  const [keypair, client] = await getWallet()

  const registerCoinTx = new Transaction()
```

Next you will need to create the correct `typeArgument` that you will need to pass to ITS when interacting with its functionality. This is needed to interact with the [generic](https://move-language.github.io/move/generics.html) `Move` functions in ITS. Generics in Sui (any function using `<T>` need to have an explicitly specified object type when they're called). In our case, the `type` needing to be passed in when interacting with ITS generics will be the type of your Coin that you created in the coin package. This type can be defined as follows: 

```javascript
const coinType = `${coinPackageId}::my_custom_coin::MY_CUSTOM_COIN`
```

TODO -> this is changing with new ITS refactor, confirm latest.
TODO -> explain basics of how to write Move calls. (ie the whole [itsPackageId::interchain_token_service::register_coin] syntax). Dont forget to talk about the BCS encodings (https://sdk.mystenlabs.com/bcs#basic-types)

When passing in arguments into a Sui function if the argument is a Sui object you need to first make a query to a move package to be able to pass that queried value in as an appropriate Move Object.

TODO the script can be run as follows

```bash
 node scripts/integrateAxelar.js --coinPackageId 0x129245163917fd5ec0a90ad83216ca1380ddb37ccbd2be246f62e905f78c88a7
‚úÖ Coin registration completed

üéØ Token ID: 0x291e9b4f659caeecf96e66c008b794dcce55f1b93bfc4f9ca49af54096316ebd
```

## Part 7 :Deploy Interchain Token on Avalanche from Sui

With your custom token, now deployed and registered on Sui, you now need to deploy a token onto another blockchain that you will eventually bridge to/from your Sui ITS integration. ITS has built-in functionality to be able to deploy tokens on a remote chain by making a cross-chain call. This can be done by triggering the `deploy_remote_interchain_token()` function on ITS.

To do this you can create a new script as follows:

```bash
touch scripts/deployRemoteToken.js
```

Then you can create the standard script boilerplate as you did in the previous scripts.

```javascript
import { Command } from 'commander'
import { Transaction } from '@mysten/sui/transactions'
import { getWallet } from '../utils/index.js'
import { ethers } from 'ethers'
import { SUI_TYPE_ARG } from '@mysten/sui/utils' 

async function run(args) {}

const registerCoinCommand = new Command()
registerCoinCommand
  .description('Register Sui coin with ITS')
  .requiredOption('--coinPackageId <coinPackageId>', 'Coin Package Id')
  .requiredOption('--tokenId <tokenId>', 'Token Id')
  .action(async (opts) => {
    try {
      await run(opts)
    } catch (err) {
      console.error('‚ùå Error:', err.message || err)
      process.exit(1)
    }
  })

registerCoinCommand.parse(process.argv)
```

For this script the arguments required are the `coinPackageId`, which you have used several times before, as well as a the `tokenId`, which you should have received when you successfully ran the `register_coin()`-> TODO fn name. In the start of your `run()` function you can go through the standard steps of 

1. Destructuring arguments
1. Obtaining your keypair and client
1. Creating a new `Transaction` object
1. Creating your `typeArgument`

```javascript
  const { coinPackageId, tokenId } = args
  const [keypair, client] = await getWallet()

  const deployRemoteTokenTx = new Transaction()
  const coinType = `${coinPackageId}::my_custom_coin::MY_CUSTOM_COIN`
```

Before calling the `deploy_remote_interchain_token()` function you will need to query your coin's `tokenId` from ITS so you can pass in the `tokenId` as an appropriate Move object. This can be done as follows:

```javascript
  const tokenIdObj = deployRemoteToken.moveCall({
    target: `${suiItsPackageId}::token_id::from_u256`,
    arguments: [deployRemoteToken.pure.u256(tokenId)],
  })
```

With `tokenId` now fetched in the appropriate format you can writeup your `MoveCall` to the `deploy_remote_interchain_token()`. 


The `deploy_remote_interchain_token()` function is written on the ITS package follows:

```rust
public fun deploy_remote_interchain_token<T>(
    self: &InterchainTokenService,
    token_id: TokenId,
    destination_chain: String,
): MessageTicket {}
```

Once executed, it make a cross-chain call to deploy a fresh [Interchain Token](/dev/send-tokens/glossary#interchain-token) on a remote blockchain. 

You can call the `deploy_remote_interchain_token()` function by passing in the the 

1. ITS object id as a type `object`
1. Token Id from the previous step. There is no need to parse the type as it was queried as a Move object.
1. Destination chain serialized as a BCS string.

You also must pass in the `coinType` as the `typeArgument` to satisfy the generic typ requirement that ITS has for the `deploy_remote_interchain_token()` function.

```javascript
  const deployRemoteTokenTicket = deployRemoteToken.moveCall({
    target: `${suiItsPackageId}::interchain_token_service::deploy_remote_interchain_token`,
    arguments: [
      deployRemoteToken.object(suiItsObjectId),
      tokenIdObj,
      deployRemoteToken.pure.string('ethereum-sepolia'),
    ],
    typeArguments: [coinType],
  })
``` 

With the `deploy_remote_interchain_token()` function called you must now call the standard [General Message Passing (GMP)](https://docs.axelar.dev/dev/general-message-passing/sui/gmp-contracts/#general-message-passing-gmp-sui-contracts) functions in order to [TODO].


The first of these functions is the [pay_gas()](/dev/general-message-passing/sui/gmp-contracts/#paygas) function, defined on the [Sui Gas Service](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/gas_service/sources/gas_service.move). It will be used to pay the cost of the cross chain transaction. Further details on gas payment (including the parameters it expects) can be found in the [Sui GMP](/dev/general-message-passing/sui/gmp-tutorial/#send-message-1) tutorial. The gas payment can be written as follows

```javascript
  const unitAmount = ethers.utils.parseUnits('1', 9).toBigInt()

  const [gas] = deployRemoteToken.splitCoins(deployRemoteToken.gas, [
    unitAmount,
  ])

  deployRemoteToken.moveCall({
    target: `${gasServicePackageId}::gas_service::pay_gas`,
    typeArguments: [SUI_TYPE_ARG],
    arguments: [
      deployRemoteToken.object(gasServiceObjectId),
      deployRemoteTokenTicket,
      gas,
      deployRemoteToken.object(keypair.getPublicKey().toSuiAddress()),
      deployRemoteToken.pure.string(''),
    ],
  })
```

Note: The gas payment passes in the generic `SUI_TYPE_ARG` as the type argument, as the gas payment is done in Sui via the native Sui coin so a different type is passed in to handle the generic. 

With the gas payment now made, the final step is to trigger the `send_message()` function defined on the [Sui Gateway](https://github.com/axelarnetwork/axelar-cgp-sui/blob/main/move/axelar_gateway/sources/gateway.move). As with the `pay_gas()` further reading on this topic can be found in the [GMP demo](/dev/general-message-passing/sui/gmp-tutorial/#send-message)

The call to `send_message()` can be made as follows:

```javascript
  deployRemoteToken.moveCall({
    target: `${gatewayPackageId}::gateway::send_message`,
    arguments: [
      deployRemoteToken.object(gatewayObjectId), // &Gateway
      deployRemoteTokenTicket, // MessageTicket
    ],
  })
```

With the `pay_gas()` and `send_message()` calls now made your script can now [TODO]

At this point the final step is to broadcast the transaction to Sui by running the `signAndExecuteTransaction` as you did in the previous scripts. This can be done as follows:

```javascript
  const deployReceipt = await client.signAndExecuteTransaction({
    signer: keypair,
    transaction: deployRemoteToken,
    options: { showObjectChanges: true, showEvents: true },
  })

  console.log('‚úÖ Remote token deployment completed:', deployReceipt)
```

You can now run the script by calling the following command:

```bash
node scripts/deployRemoteToken.js --coinPackageId 0x129245163917fd5ec0a90ad83216ca1380ddb37ccbd2be246f62e905f78c88a7 --tokenId 0x291e9b4f659caeecf96e66c008b794dcce55f1b93bfc4f9ca49af54096316ebd
``` 

```bash
node scripts/deployRemoteToken.js --coinPackageId 0x129245163917fd5ec0a90ad83216ca1380ddb37ccbd2be246f62e905f78c88a7 --tokenId 0x291e9b4f659caeecf96e66c008b794dcce55f1b93bfc4f9ca49af54096316ebd
üöÄ Deploying remote interchain token...
‚úÖ Remote token deployment completed: {
  digest: '2GffLMzzsXMCDMs4AhhiR6txFGefmtFBqtnUh7infcq6',
   events: [
    ...
   ]
```

The live [cross-chain](https://testnet.axelarscan.io/gmp/2GffLMzzsXMCDMs4AhhiR6txFGefmtFBqtnUh7infcq6) call should now be visible on Axelarscan and you should now have a token deployed on your specified destination chain. 

You can confirm your code is up to date with the [Checkpoint 7](TODO)

## Part 8: Transfer Tokens Between Sui and EVM

The final step is to now send a cross-chain transfer between your two deployed tokens. You should have a balance in your wallet from the `mint` script that you ran earlier. 